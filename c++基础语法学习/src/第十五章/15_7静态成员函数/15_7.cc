#include<iostream>



class Something
{
private:
    static inline int s_value{1};

public:
    Something()
    {}

    //静态成员函数
    static int getValue(){
        return s_value++;
    }

};
//警告
//使用所有静态成员编写类时要小心。尽管这种“纯静态类”（也称为“单态”）可能很有用，但它们也有一些潜在的缺点。

//首先，由于所有静态成员只实例化一次，因此无法拥有纯静态类的多个副本（如果不克隆类并重命名它）。例如，如果您需要两个独立的 IDGenerator ，这对于纯静态类来说是不可能的。

//其次，在关于全局变量的课程中，您了解到全局变量是危险的，因为任何一段代码都可能更改全局变量的值，并最终破坏另一段看似不相关的代码。这同样适用于纯静态类。由于所有成员都属于类（而不是类的对象），并且类声明通常具有全局作用域，因此纯静态类本质上等同于在全局可访问的命名空间中声明函数和全局变量，具有全局变量所具有的所有必要缺点。

//与其编写包含所有静态成员的类，不如考虑编写一个普通类并实例化它的全局实例（全局变量具有静态持续时间）。这样，可以在适当的时候使用全局实例，但如果有用，仍然可以实例化本地实例。

int main()
{
    //静态成员函数可以直接通过类名和作用域解析运算符::直接
    //访问 而不需要实例化类
    std::cout << Something::getValue() << '\n';
    std::cout << Something::getValue() << '\n';
    std::cout << Something::getValue() << '\n';
    return 0;
}
