### 总结

复合语句或块是一组零个或多个语句，编译器将其视为单个语句。
块以符号开头，以 { } 符号结尾，要执行的语句位于两者之间。
块可以在允许单个语句的任何地方使用。块的末尾不需要分号。
块通常与执行多个语句结合使用 `if statements` 。  


<br>

<b>用户定义的命名空间</b>是您为自己的声明定义的命名空间。
由C++（如 `global namespace` ）或库（如 `namespace std` ）
提供的命名空间不被视为用户定义的命名空间  


<br>

可以通过<b>范围解析运算符</b>  `(::)` 访问命名空间中的声明。
范围解析运算符告诉编译器，应在左侧操作数的范围内查找右侧操作数指定的关键字。
如果未提供左侧操作数，则假定全局命名空间。  


<br>

局部变量是在函数中定义的变量（包括函数参数）。局部变量具有<b>块范围</b>，
这意味着它们从定义点到定义块的末尾都在范围内。
局部变量具有<b>自动存储持续时间</b>，这意味着它们在定义点创建，并在定义它们的块结束时销毁。  

<br>

在嵌套块中声明的名称可以<b>遮蔽</b>或<b>隐藏</b>外部块中同名变量。应避免这种情况.  

<br>

全局变量是在函数外部定义的变量。全局变量具有<b>文件范围</b>，
这意味着它们从声明点到声明它们的文件末尾都是可见的。
全局变量具有<b>静态持续时间</b>，这意味着它们在程序启动时创建，并在程序结束时销毁。尽可能避免动态初始化静态变量  

<br>

关键字的<b>链接</b>确定该名称的其他声明是否引用同一对象。
局部变量没有链接。具有内部链接的关键字可以在单个文件中查看和使用，但不能从其他文件访问。
具有<b>外部链接</b>的关键字既可以从定义它们的文件中查看和使用，
也可以从其他代码文件（通过前向声明）查看和使用。

<br>

尽可能避免使用非常量全局变量。Const 全局变量通常被认为是可以接受的。
如果编译器支持 C++17，则对全局常量使用<b>内联变量(inline)</b>。

<br>
局部变量可以通过 <b>static</b> 关键字给出静态持续时间。

<br>

<b>限定名称</b>是包含关联作用域的名称（`std::string`）。 
<b>非限定名称</b>是不包含范围限定符的名称（例如 `string` ）

<br>
可以使用<b> using <b>语句（包括使用<b>using declarations</b>和
<b>using directives</b>）来避免使用显式命名空间限定标识符。
<b>using declarations</b> 允许我们使用非限定名称（没有作用域）作为限定名称的别名。
<b>using directives</b> 将所有标识符从命名空间导入到 using 指令的作用域中。
通常应避免这两种情况。

<br>

<b>内联函数</b>最初设计为请求编译器将函数调用替换为函数代码的内联扩展。
您不需要为此目的使用 inline 关键字，因为编译器通常会为您确定这一点。
在现代C++中， `inline` 关键字用于将函数从单定义规则中免除，
从而允许将其定义导入到多个代码文件中。内联函数通常在头文件中定义，
因此可以将它们 `#included` 到需要它们的任何代码文件中。

<br>

<b>constexpr 函数</b>是一个函数，其返回值可以在编译时计算。
为了使函数成为 constexpr 函数，我们只需在返回类型前面使用 `constexpr` 关键字。
如果在需要 constexpr 值的上下文中使用返回值，
则必须在编译时计算符合编译时计算条件的 constexpr 函数。
否则，编译器可以在编译时或运行时自由计算函数。

<br>

C++20 引入了关键字 ，该关键字 `consteval` 用于指示函数必须在编译时求值，
否则将导致编译错误。此类函数称为即时函数(immediate function)

<br>

最后，C++ 支持<b>未命名的命名空间(unnamed namespaces)</b>，这些命名空间隐式地将命名空间的所有内容视为具有内部链接。
C++还支持<b>内联命名空间(inline namespaces)</b>，这些命名空间为命名空间提供了一些基元版本控制功能。
