#include<iostream>
#include"constantsC17.h"

//在某些应用程序中，可能需要在整个代码中使用某些符号常量（而不仅仅是在一个位置）。
//这些可以包括不变的物理或数学常数（例如 pi 或阿伏伽德罗数），或特定于应用的“调整”值（例如摩擦或重力系数）。
//与其在每个需要它们的文件中重新定义这些常量（违反“不要重复自己”规则），不如在中心位置声明它们一次，并在需要的地方使用它们。
//这样，如果您需要更改它们，只需在一个位置更改它们，这些更改就可以传播出去。



// 作为内联变量的全局常量 (C++17)

// C++17引入了一个名为. inline variables 在C++，该术语 inline 已经演变为“允许多个定义”。
// 因此，行联变量是允许在多个文件中定义而不违反一个定义规则的变量。默认情况下，内联全局变量具有外部链接

// 链接器会将变量的所有内联定义合并到单个变量定义中（从而满足一个定义规则）。这允许我们在头文件中定义变量，并将它们视为在某处.cpp文件中只有一个定义。
// 假设您有一个正常的常量，您将该常量 #including 到 10 个代码文件中。如果没有内联，你会得到 10 个定义。
// 使用内联时，编译器选择 1 个定义作为规范定义，因此您只能获得 1 个定义。这意味着您可以节省 9 个常量的内存
// Constexpr 内联变量还将在包含它们的所有文件中保留其 constexpr-ness，因此它们可以在任何需要 constexpr 值的地方使用。
// 这为编译器提供了比运行时常量（或非常量）变量更多的优化机会
int main()
{
    std::cout << "c++17作为内联变量的全局变量: " << constants_c17::avogadro << '\n';
    return 0;
}

/*
    由于全局符号常量应命名（以避免与全局命名空间中的其他标识符发生命名冲突），因此不需要使用“g_”命名前缀
    现在，符号常量将只实例化一次（在 constants.cpp），
    而不是在 #included constants.h 的每个代码文件中，
    而且这些常量的所有使用都将链接到在 constants.cpp 中实例化的版本。
    对 constants.cpp 所做的任何修改都只需要重新编译 constants.cpp
*/

/*
前置声明的作用：

 可以减少编译依赖、减少编译时间(如果头文件被修改，会导致多次重新编译)；
 可以隐藏细节；
 可以减少类大小(前置声明会告诉这个类的存在,而不用提供类定义的所有细节)；
 减少include，防止类间相互引用形成依赖，造成编译不通过.
 以下是在Google C++风格指南中对前置声明的介绍：

 尽可能地避免使用前置声明。使用#include 包含需要的头文件即可。
 所谓前置声明(forward declaration)是类、函数和模板的纯粹声明，没伴随着其定义.
 优点：

 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。
 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。
 缺点：

 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API.例如扩大形参类型，加个自带默认参数的模板形参等等。
 前置声明来自命名空间std:: 的 symbol 时，其行为未定义。
 很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义.
*/
