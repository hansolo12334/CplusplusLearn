#include<iostream>

//未命名命名空间（也称为匿名命名空间）是在没有名称的情况下定义的命名空间，如下所示
namespace
{
    void doSomething()
    {
        std::cout << "vvv\n";
    }
} // namespace

/*
在未命名命名空间中声明的所有内容都被视为父命名空间的一部分。因此，即使函数是在未命名的命名空间中定义的，函数 doSomething() 本身也可以从父命名空间（在本例中为全局命名空间）访问，这就是为什么我们可以在没有任何限定符的情况下调用 doSomething() from main() 的原因。

这可能会使未命名的命名空间看起来毫无用处。但未命名命名空间的另一个影响是，未命名命名空间中的所有标识符都被视为具有内部链接，这意味着在定义未命名命名空间的文件之外看不到未命名命名空间的内容。

当您希望确保大量内容保留在给定文件的本地时，通常会使用未命名命名空间，因为将此类内容聚类到单个未命名命名空间中比单独将所有声明标记为 static 更容易。未命名的命名空间还将程序定义的类型（我们将在后面的课程中讨论）保留在文件的本地，对此没有替代的等效机制可以执行

对于函数，这实际上与将未命名命名空间中的所有函数定义为静态函数相同。以下程序实际上与上述程序相同：
*/

static void doSomething1() // 只能在当前文件内访问
{
    std::cout << "vvv\n";
}


int main()
{
    doSomething();
    doSomething1();
    return 0;
}
