# 范围_持续时间和链接总结
## 1. 范围（Scope）总结  
    标识符的作用域决定了可以在源代码中访问标识符的位置  
* 具有块（局部）作用域的变量只能从声明点访问，直到声明它们的块（包括嵌套块）的末尾。这包括：  
    * 局部变量  
    * 函数参数  
    * 在块内声明的程序定义类型定义（如枚举和类）  
* 具有全局范围的变量和函数可以从声明点到文件末尾进行访问。这包括：  
  * 全局变量
  * 函数
  * 在命名空间内或全局范围内声明的程序定义类型定义（如枚举和类）
## 2. 持续时间（Duration）总结
    变量的持续时间决定了何时创建和销毁变量
* 具有自动持续时间的变量在定义点创建，并在退出它们所属的块时销毁。这包括：  
  * 局部变量
  * 函数参数
* 具有静态持续时间的变量在程序开始时创建，在程序结束时销毁。这包括：
  * 全局变量
  * 静态局部变量
## 3. 链接（Linkage）总结
    标识符的链接决定了标识符的多个声明是否引用同一实体（对象、函数、引用等）。
* 没有链接的标识符意味着标识符仅引用自身。这包括：   
  * 局部变量
  * 在块内声明的程序定义类型定义（如枚举和类）
* 具有内部链接的标识符可以在声明该文件中的任何位置访问。这包括:
  * 静态全局变量（已初始化或未初始化）
  * 静态函数
  * 常量全局变量
  * 在未命名空间中声明的函数
  * 在未命名命名空间中声明的程序定义类型定义（如枚举和类）
* 具有外部链接的标识符可以在声明的文件或其他文件（通过前向声明）中的任何位置访问。这包括：
  * 函数
  * 非 常量全局变量（已初始化或未初始化）
  * 外部常量全局变量  
  * 内联常量全局变量  

 如果定义编译到多个.cpp文件中（由于违反一个定义规则），则具有外部链接的标识符通常会导致重复的定义链接器错误。此规则有一些例外（对于类型、模板以及内联函数和变量）——我们将在以后的课程中讨论这些主题时进一步介绍这些例外。  
<br>

## 可变范围、持续时间和链接摘要
由于变量具有范围、持续时间和链接，因此让我们在图表中总结：  

| 类型     | 例子     | 范围     | 持续时间 | 链接 | 注释|
| -------- | -------- | -------- | -------- | -------- | -------- |
| Local variable<br> 局部变量  |int x; | Block |      自动       | None |  |
| Static local variable <br>静态局部变量 | static int s_x; | Block | Static | None |  |
| Dynamic variable <br>动态变量 |int *x{new int{}}; | Block | Dynamic | None |  |
| Function parameter <br>函数参数 | void foo(int x); | Block | 自动 | None  |  |
| External non-constant global variable <br>外部非常量全局变量 | int g_x; | File | Static | 外部 | 已初始化或未初始化 |
| Internal non-constant global variable <br>内部非常量全局变量 | static int g_x; | File | Static | 内部 | 已初始化或未初始化 |
| Internal constant global variable <br>内部常量全局变量 | constexor int g_x{1}; | File | Static | 内部 | 必须初始化 |
| External constant global variable <br>外部常量全局变量 | extern const int g_x{1}; | File | Static | 外部 | 必须初始化 |
| Inline constant global variable (C++17) <br>内联常量全局变量 （C++17） | inline constexpr int g_x{1}; | File | Static  | 外部 | 必须初始化  |
<br>
## 前向声明总结
    可以使用前向声明访问另一个文件中的函数或变量。声明变量的作用域与往常一样（全局的全局范围，局部变量的块范围）。  
| 类型|例子|注释|
|--------|--------|--------|
|Function forward declaration <br> 函数前向声明|void foo(int x);|Prototype only, no function body <br> 仅原型，无功能体|
|Non-constant variable forward declaration <br> 非恒定变量前向声明|extern int g_x;| 必须未初始化|
|Const variable forward declaration <br> 常量变量前向声明|extern const int g_x;|必须未初始化|
| Constexpr variable forward declaration <br> Constexpr 变量前向声明|extern constexpr int g_x;|Not allowed, constexpr cannot be forward declared <br> 不允许，不能转发声明 constexpr|  

<br>

## 储存类关键字到底是什么？  
当用作标识关键字的一部分时， static 和 extern 关键字称为<b>存储类关键字(storage class specifiers)</b>。在这种情况下，他们设置标识符的存储持续时间和链接。  
C++支持 4 个活动存储类关键字  
|关键字|含义|注释|
|--------|--------|--------|
|extern|静态（或thread_local）存储持续时间和外部链接||
|static|静态（或thread_local）存储持续时间和外部链接||
|thread_local|thread storage duration <br>线程存储持续时间||
|mutable|object allowed to be modified even if containing class is const <br> 允许修改的对象，即使包含类是常量||
|auto|自动存储持续时间|在 C++11 中已弃用|
|register|automatic storage duration and hint to the compiler to place in a register <br> 自动存储持续时间和提示编译器放置在寄存器中|在 C++17 中已弃用|
