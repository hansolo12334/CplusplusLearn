#include<iostream>


//地址运算符 &

// &符号容易引起混淆，因为它根据上下文具有不同的含义：
// 当跟在类型名称后面时，&表示左值引用： int& ref 。
// 当在表达式的一元上下文中使用时，&是地址运算符： std::cout << &x 。
// 在表达式的二进制上下文中使用时，&是按位 AND 运算符：。 std::cout << x & y

//引用运算符  *
// 可以对地址做的最有用的事情是访问存储在该地址的值。引用运算符 （*）（有时也称为间接寻址运算符）以左值的形式返回给定内存地址处的值

//建议： 始终初始化指针

//就像引用的类型必须与所引用对象的类型匹配一样，指针的类型必须与所指向对象的类型匹配：
int i{5};
double d{7.0};

int *iPtr{&i};
//int *iPtr2{&d};// int类型的指针不能指向 double类型
double *dPtr{&d};
//double *dPtr2{&i};//double类型的指针不能指向 int类型


//指针和赋值
/*
可以通过两种不同的方式将赋值与指针一起使用：
1. 更改指针指向的内容（通过为指针分配新地址）
2. 更改所指向的值（通过为取消引用的指针分配一个新值）
*/


/*
 1. 当我们使用没有取消引用的指针 （ptr） 时  ，我们正在访问指针持有的地址。修改此 （ ptr = &y ） 会更改指针指向的内容。
 2. 当我们取消引用指针 （ *ptr ） 时，我们正在访问所指向的对象。修改此 （ *ptr = 6; ） 将更改所指向对象的值。
*/



/*
指针的行为很像左值引用
指针和引用都提供了一种间接访问另一个对象的方法。主要区别在于，对于指针，我们需要显式获取要指向的地址，并且必须显式取消引用指针才能获取值。对于引用，地址和取消引用是隐式发生的。

指针和引用之间还有一些其他值得一提的差异：
 引用必须初始化，指针不需要初始化（但应该初始化）。
 引用不是对象，指针是
 引用不能重新拔插（更改为引用其他内容），指针可以更改它们指向的内容。
 引用必须始终绑定到对象，指针可以不指向任何内容（空指针）
 引用是“安全的”（在悬空引用之外），指针本质上是危险的
*/

/*
指针的大小
指针的大小取决于编译可执行文件的体系结构（32 位可执行文件使用 32 位内存地址），因此，32 位计算机上的指针为 32 位（4 字节）。对于 64 位可执行文件，指针为 64 位（8 字节）。请注意，无论指向的对象的大小如何，都是如此
指针的大小始终相同。这是因为指针只是一个内存地址，访问内存地址所需的位数是恒定的
*/

int main()
{
    int x{ 5 };
    std::cout << x << '\n';  // print the value of variable x
    std::cout << &x << '\n'; // print the memory address of variable x

    std::cout << *(&x) << '\n';

    return 0;
}
